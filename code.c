#include "peg.h"
#include <stdlib.h>

#define CODE_LENGTH 4 // the fixed length of the code
#define NUM_COLORS 8

typedef struct {
	peg_t *pegs[CODE_LENGTH]; // array of pointer to pegs
} code_t;

// Miru :)
// creating a random code - generated by the computer
code_t* code_create_random(void) {
	code_t* code = malloc(sizeof(code_t));
	if(!code) return NULL;

	for ( int i = 0; i < CODE_LENGTH; i ++ ) {
		int color = rand() % NUM_COLORS;
		code->pegs[i] = peg_create(color);
	}

	return code;
}

// Miru :)
// creating a manual code - entered by user
code_t* code_create_manual(void) {
	code_t* code = malloc(sizeof(code_t));
	if (!code) return NULL;

	printf("Enter %d colors for your code!\n", CODE_LENGTH);
	printf("0 = RED, 1 = ORANGE, 2 = YELLOW, 3 = GREEN, 4 = BLUE, 5 = PURPLE, 6 = PINK, 7 = BLACK.\n");

	for ( int i = 0; i < CODE_LENGTH; i ++ ) {
		int color;
		while(1) {
			printf("Color of peg %d should be:", i + 1);
			if ( scanf("%d", &color) != 1 ) { // checks if input is a number
				while (getchar() != '\n'); // if user typeds a chracter it clears input
				printf("Please enter a valid number!! :(\n");
				continue; // skipping the rest of the loop
			}

			if ( color >= 0 && color < NUM_COLORS) break;
			printf("Hmm.. the number you entered isn't right. :/ \n"); // in case the numbered entered isn't in the set range
		}

		code->pegs[i] = peg_create(color);
	}
	return code;
}

// Miru :)
void code_free(code_t* code) {
	if (!code) return; // safety check :P

	for ( int i = 0; i < CODE_LENGTH; i ++ ) { // freeing each peg
		peg_free(code->pegs[i]);
	}

	free(code); // freeing the struct

}

// Miru :)
void code_compare(const code_t* secret, const code_t* guess, int* total_match, int* partial_match) {

	*total_match = 0;
	*partial_match = 0;

	// preventing recounting pegs
	bool secret_used[CODE_LENGTH] = {false};
	bool guess_used[CODE_LENGTH] = {false};

	// exact matches
	for ( int i = 0; i < CODE_LENGTH; i ++ ) {
		if ( peg_equals(secret->pegs[i], guess->pegs[i])) {
			(*total_match)++;
			secret_used[i] = true;
			guess_used[i] = true;
		}
	}

	// partial matches
	for ( int i = 0; i < CODE_LENGTH; i ++ ) {
		if ( guess_used[i] ) continue; // skip exact matches
		
	for ( int j = 0; j < CODE_LENGTH; j ++ ) {
		if ( secret_used[j] ) continue;

	// color match
if ( peg_equals(secret->pegs[j], guess->pegs[i])) {
	(*partial_match)++;
	secret_used[j] = true;
	break;
			}
		}
	}
}

// Miru :)
peg_t* get_peg(const code_t* code, int index) {
	if (!code) return NULL; // safety check

	if (index < 0 || index >= CODE_LENGTH) return NULL; // safety check 2

	return code->pegs[index];
}